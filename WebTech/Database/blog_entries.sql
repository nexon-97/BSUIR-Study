-- phpMyAdmin SQL Dump
-- version 4.0.10.14
-- http://www.phpmyadmin.net
--
-- Host: localhost
-- Generation Time: May 11, 2016 at 11:59 PM
-- Server version: 5.5.23
-- PHP Version: 5.3.10

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- Database: `nexonlab`
--

-- --------------------------------------------------------

--
-- Table structure for table `blog_entries`
--

CREATE TABLE IF NOT EXISTS `blog_entries` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `category` int(11) NOT NULL,
  `image` varchar(255) NOT NULL DEFAULT 'img/noimage.jpg',
  `creation_date` date NOT NULL,
  `author` int(11) NOT NULL,
  `title` varchar(128) NOT NULL,
  `desc` text NOT NULL,
  `short_desc` text NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `id_2` (`id`),
  KEY `id` (`id`),
  KEY `category` (`category`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=5 ;

--
-- Dumping data for table `blog_entries`
--

INSERT INTO `blog_entries` (`id`, `category`, `image`, `creation_date`, `author`, `title`, `desc`, `short_desc`) VALUES
(1, 2, 'img/cpp_post1.jpg', '2016-02-22', 2, '﻿Custom SoundNode for Multiplayer in UE4', '<p>Ever since the first public release of Unreal Engine 4 I’ve been using a neat little custom SoundNode that makes life easier for audio designers\nwhen dealing with mono/stereo sound playback in (networked) games. The node originates from the official ShooterGame sample content available on\nthe Learn-tab of the UE4 launcher. I’ve used it in several others projects too including Switch and the SurvivalGame sample project.</p>\n<p>The core functionality of the node is to check whether the owner that plays the sound is a local player or a remotely replicated client. This makes\nit really easy to play stereo sounds for your controlled Pawn and use 3D-attenuated sounds for any other player or AI controlled bot that exists in\nthe same session.</p>\n<p align="center"><img style="width: 80%;" src="img/post_attachments/attach1.jpg"/></p>\n<p>Below you’ll find a code dump of the source I’ve been using. The compiler will complain about a few pieces including SURVIVALGAME_API and the #include\n“SurvivalGame.h” update these to your own project equivalent.</p>\n\n<h4>Header File</h4>\n<pre><code>#pragma once\n \n#include "Sound/SoundNode.h"\n#include "SoundNodeLocalPlayer.generated.h"\n \n/**\n* Choose different branch for sounds attached to locally controlled player\n*\n* Originates from ShooterGame project by Epic Games.\n*/\nUCLASS(hidecategories = Object, editinlinenew)\nclass SURVIVALGAME_API USoundNodeLocalPlayer : public USoundNode\n{\n// Make sure you update the *_API above to match your own project eg MYPROJECT_API\n  GENERATED_BODY()\n \n  virtual void ParseNodes(FAudioDevice* AudioDevice, const UPTRINT NodeWaveInstanceHash, FActiveSound& ActiveSound, const FSoundParseParameters& ParseParams, TArray<FWaveInstance*>& WaveInstances) override;\n \n  virtual void CreateStartingConnectors(void) override;\n \n  virtual int32 GetMaxChildNodes() const override;\n \n  virtual int32 GetMinChildNodes() const override;\n \n#if WITH_EDITOR\n \n  virtual FText GetInputPinName(int32 PinIndex) const override;\n \n#endif\n \n};\n</code></pre>\n\n<h4>Source File</h4>\n<pre><code>// Update this header to your own project (eg. MyProject.h)\n#include "SurvivalGame.h"\n#include "SoundDefinitions.h"\n#include "SoundNodeLocalPlayer.h"\n \n \nvoid USoundNodeLocalPlayer::ParseNodes(FAudioDevice* AudioDevice, const UPTRINT NodeWaveInstanceHash, FActiveSound& ActiveSound, const FSoundParseParameters& ParseParams, TArray<FWaveInstance*>& WaveInstances)\n{\n	// The accesses to the Pawn will be unsafe once we thread audio, deal with this at that point\n	check(IsInGameThread());\n \n	AActor* SoundOwner = ActiveSound.GetAudioComponent() ? ActiveSound.GetAudioComponent()->GetOwner() : nullptr;\n	APlayerController* PCOwner = Cast<APlayerController>(SoundOwner);\n	APawn* PawnOwner = (PCOwner ? PCOwner->GetPawn() : Cast<APawn>(SoundOwner));\n \n	const bool bLocallyControlled = PawnOwner && PawnOwner->IsLocallyControlled() && Cast<APlayerController>(PawnOwner->Controller);\n	const int32 PlayIndex = bLocallyControlled ? 0 : 1;\n \n	if (PlayIndex < ChildNodes.Num() && ChildNodes[PlayIndex])\n	{\n		ChildNodes[PlayIndex]->ParseNodes(AudioDevice, GetNodeWaveInstanceHash(NodeWaveInstanceHash, ChildNodes[PlayIndex], PlayIndex), ActiveSound, ParseParams, WaveInstances);\n	}\n}\n \n \nvoid USoundNodeLocalPlayer::CreateStartingConnectors()\n{\n	InsertChildNode(ChildNodes.Num());\n	InsertChildNode(ChildNodes.Num());\n}\n \n \n#if WITH_EDITOR\nFText USoundNodeLocalPlayer::GetInputPinName(int32 PinIndex) const\n{\n	return (PinIndex == 0) ? NSLOCTEXT("Survival", "InputPinName", "Local") : NSLOCTEXT("Survival", "InputPinName", "Remote");\n}\n#endif\n \n \nint32 USoundNodeLocalPlayer::GetMaxChildNodes() const\n{\n	return 2;\n}\n \n \nint32 USoundNodeLocalPlayer::GetMinChildNodes() const\n{\n	return 2;\n}\n</code>\n</pre>\n\n<p><i>Code was last updated for 4.10</i></p>\n<p>The node is written in C++, if you are already using a C++ project, you can drop these into your code project and after a few small changes to\nthe file to match your project naming (see comments in the source below) you should be good to go.</p>\n<p><i>For Blueprint users, you can still use this code quite easily. Make sure you have <u>Visual Studio 2015</u> (see url for install instructions)\ninstalled before you proceed. Afterwards, go into the editor and go to File > New C++ Class… This prompts you to add a new source file to your\nproject, name it “SoundNodeLocalPlayer” and base it on “USoundNode” (that’s the parent class that we are extending) I won’t go into detail on\ncompiling your code.</i></p>', 'Ever since the first public release of Unreal Engine 4 I’ve been using a neat little custom SoundNode that makes life easier for audio designers when dealing with mono/stereo sound playback in (networked) games. The node originates from the official ShooterGame sample content available on the Learn-tab of the UE4 launcher. I’ve used it in […]'),
(2, 2, 'img/cpp_post2.jpg', '2015-10-12', 1, 'Building Shooter AI in Unreal Engine 4', '<p>You may have seen my earlier blog post about a 4-player coop game I’m working on inside of Unreal Engine 4. It had the first iteration\non ranged combat AI and they proved to be a formidable enemy. The problem was they got stale pretty quick, with simplistic and predictable\nbehaviors. The new AI improvements are a first step at addressing this issue.</p>\n<p align="center"><img style="width: 80%;" src="img/post_attachments/attach2.jpg" /></p>\n<h3>New AI Behaviors</h3>\n<p>Along with the concept of multiple teams, the bots now do some bookkeeping on their most threatening enemy (“aggro”) which is based\non distance to an enemy (if within the boundary of ears/visions), the amount of damage taken from an enemy and if the other bot is seen\nor heard through weapon fire or footsteps. Meaning that whenever a bot is attacked by a (melee) bot that is running up close, a spike in\naggro makes him the most threatening, telling the bot to pick him as the new target instead of the current enemy far away.</p>\n<p align="center"><img style="width: 80%;" src="img/post_attachments/attach3.gif" /></p>\n<p>The next step is to start digging into EQS (Environment Query System) to improve both pathing and decision-making when picking a good\ndestination to attack or defend a player or location. As of right now the bots pick a reachable position within a radius of the current enemy.\nUsing EQS you can figure out if a node in the world has line of sight to the enemy or if it’s partial/full cover etc. giving the AI a better\nunderstanding of the environment and therefore making them a more interesting opponent.</p>\n<h3>Stresstesting AI</h3>\n<p>With all the recent changes to AI, and all the firepower that’s available it was time for a stress test to see how it performs and\ndeals with large number of AI agents. An open map with 80+ bots carrying assault rifles, rocket launchers, explosive slug grenades and\nsniper rifles – the end result is a party. (please mind your sound level)</p>\n<p>[VIDEO 1]</p>\n<h3>Demorecording</h3>\n<p>Since around Unreal Engine 4.6 you can record your gameplay and play it back from any angle, much like the Halo-series and Call of Duty:\nBlack Ops. The only requirement is for your game to be networked (single player games would need to enable replication too for this to function)</p>\n<p>I’ve starting to work on some spectator and playback functionality to review/debug AI behavior and to make footage capture a lot easier.\nThis works too for playtest sessions, allowing me to review a playtest session and see how both players and bots performed! Below is the first\nresult of a freezeframe flythrough of the AI stresstest session.</p>\n<p>[VIDEO 2]</p>', 'You may have seen my earlier blog post about a 4-player coop game I’m working on inside of Unreal Engine 4. It had the first iteration on ranged combat AI and they proved to be a formidable enemy. The problem was they got stale pretty quick, with simplistic and predictable behaviors. The new AI improvements […]'),
(3, 1, 'img/post4.jpg', '2014-09-20', 1, 'Gradient Fresnel Shading for Cinematic Lighting in Unreal 4', '<h3>Background</h3>\n<p>During the Unreal 4 Beta I experimented a lot with materials, one of these experiments was inspired by Star Wars: The Old Republic’s\ncinematic character lighting presentation. I wondered how their ambient fresnel shading could be replicated in Unreal 4 and ended up with\nsomething that closely resembles the original shading results. After several months of leaving it in an abandoned project I decided it\ncould be of use for the Unreal 4 Community and build a demo with some new features (Z-clamped fresnel and simplied to single Material\nFunction) a download is available at the bottom of this page!</p>\n<p align="center"><img style="width: 80%;" src="img/post_attachments/attach4.gif" /></p>\n<h3>The Basics</h3>\n<p>The basic idea behind this shading effect is to provide a more diverse palette of colors in any given environment or character with\npredictable results regardless of scene light orientation. Fresnel lighting works well from any angle and is therefor well suited for\nin-game cinematic lighting. This is exactly why SW:TOR applied this effect on their characters – to get a consistant lighting model\nregardless of camera points during in-game conversations. The gradient texture can we swapped based on the level or even the current\nroom a player is in. In SW:TOR every planet has a unique gradient texture to define light colors on both characters and environment.\n(see SW:TOR sample image at the bottom)</p>\n<p>You can create any gradient texture in Photoshop and apply it to the material. Theoretically texture height doesn’t need to be more\nthan 1 pixel since we sample U-value based on normal and always use V = 1, I simply added some extra pixels for visibility. The color\non the right of the texture is applied to the surface directly facing the “sun” (LightDirection parameter) the left side is the shadow\nside of the mesh. Any pixel in between is sampled from the texture based on the PixelNormal. For more details I recommend checking out\nthe original presentation by Bioware.</p>\n<p>I tried to illustrate this “wrapping” of this gradient texture by adding a ribbon around the spheres. You can see the lighting move\nalong with the ribbon as they rotate based on the changing light direction parameter. Fun fact that may be of interest to anyone working\nwith materials is that the ribbon is actually the same sphere mesh, but with opacity masked based on lightdirection (cross) pixel normal\nto get an animated ribbon effect.</p>\n<p align="center"><img style="width: 80%;" src="img/post_attachments/attach5.jpg" /></p>\n<h3>Reference screenshot from Star Wars: The Old Republic</h3>\n<p>The fresnel effect in the image is most noticable on the left side of the character and on the edges of the environment geometry.\nThis screenshot was taken on Alderaan and uses a white + blue gradient texture. Planets like Korriban use a mostly red gradient.</p>\n<p align="center"><img style="width: 80%;" src="img/post_attachments/attach6.jpg" /></p>', 'Background During the Unreal 4 Beta I experimented a lot with materials, one of these experiments was inspired by Star Wars: The Old Republic’s cinematic character lighting presentation. I wondered how their ambient fresnel shading could be replicated in Unreal 4 and ended up with something that closely resembles the original shading results. After several […]'),
(4, 3, 'img/noimage.jpg', '2016-05-09', 1, 'OpenGL против DirectX', 'Это полный текст статьи', 'В этой статье я рассмотрю основные особенности и отличия технологий DirectX и OpenGL.');

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
